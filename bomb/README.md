# 说明
该实验是提供了一个可执行程序，需要输入6个字符串，一旦输入错误就会‘爆炸’！  
逼迫你使用gdb进行断点调试分析。  
实验似乎是分为在线版本和离线版本，用于自动计分之类。  
但也大概仅限于cmu自己的学生。  

我们下载到的self-study handout自学手册中的readme只有下面一句话：
> This is an x86-64 bomb for self-study students. 

关于gdb的使用可以参考[此文档](http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf)  
（这也是我头一次用gdb调试……）

# 实验过程
从bomb.c中我们可以看到程序的大体流程，每个炸弹的判定都在名为phase_x的函数中，所以接下来主要看的就是在这几个函数。我的做法是用disas查看汇编命令，然后自己在纸上写程序流程和寄存器的值，遇到不好判断的地方可以采用断点调试的方法。
## phase_1
在终端运行`./bomb`得到如下提示：
> Welcome to my fiendish little bomb. You have 6 phases with  
which to blow yourself up. Have a nice day!  
  
在另一个终端使用gdb调试`gdb bomb`，然后先看看第一题的函数汇编代码，输入`disas phase_1`,得到：
  
>(gdb) disas phase_1  
Dump of assembler code for function phase_1:  
   0x0000000000400ee0 <+0>:	sub    $0x8,%rsp  
   0x0000000000400ee4 <+4>:	mov    $0x402400,%esi  
   0x0000000000400ee9 <+9>:	callq  0x401338 <strings_not_equal>  
   0x0000000000400eee <+14>:	test   %eax,%eax  
   0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>  
   0x0000000000400ef2 <+18>:	callq  0x40143a <explode_bomb>  
   0x0000000000400ef7 <+23>:	add    $0x8,%rsp  
   0x0000000000400efb <+27>:	retq   

第一题还是比较简单，在+4处为esi赋值了一个立即数，然后调用`strings_not_equal`。所以可以先看看这个立即数的内容：
>(gdb) x/s 0x402400  
0x402400:	"Border relations with Canada have never been better."

这就很明显了，把这个字符串输入第一个运行bomb的终端，第一个炸弹就拆掉了。(*PS.不同版本的实验字符串内容可能有所差别*)至于`strings_not_equal`函数的具体内容可以不用理会，应该就是比较字符串，感兴趣也可以用`disas`命令查看。
## phase_2
第一个炸弹拆除后程序会提示你继续输入，像这样
>Phase 1 defused. How about the next one?

还是先看看phase_2函数的内容，输入`disas phase_2`:
>(gdb) disas phase_2  
Dump of assembler code for function phase_2:  
   0x0000000000400efc <+0>:	push   %rbp  
   0x0000000000400efd <+1>:	push   %rbx  
   0x0000000000400efe <+2>:	sub    $0x28,%rsp  
   0x0000000000400f02 <+6>:	mov    %rsp,%rsi  
   0x0000000000400f05 <+9>:	callq  0x40145c <read_six_numbers>  
   0x0000000000400f0a <+14>:	cmpl   $0x1,(%rsp)  
   0x0000000000400f0e <+18>:	je     0x400f30 <phase_2+52>  
   0x0000000000400f10 <+20>:	callq  0x40143a <explode_bomb>  
   0x0000000000400f15 <+25>:	jmp    0x400f30 <phase_2+52>  
   0x0000000000400f17 <+27>:	mov    -0x4(%rbx),%eax  
   0x0000000000400f1a <+30>:	add    %eax,%eax  
   0x0000000000400f1c <+32>:	cmp    %eax,(%rbx)  
   0x0000000000400f1e <+34>:	je     0x400f25 <phase_2+41>  
   0x0000000000400f20 <+36>:	callq  0x40143a <explode_bomb>  
   0x0000000000400f25 <+41>:	add    $0x4,%rbx  
   0x0000000000400f29 <+45>:	cmp    %rbp,%rbx  
   0x0000000000400f2c <+48>:	jne    0x400f17 <phase_2+27>  
   0x0000000000400f2e <+50>:	jmp    0x400f3c <phase_2+64>  
   0x0000000000400f30 <+52>:	lea    0x4(%rsp),%rbx  
   0x0000000000400f35 <+57>:	lea    0x18(%rsp),%rbp  
   0x0000000000400f3a <+62>:	jmp    0x400f17 <phase_2+27>  
   0x0000000000400f3c <+64>:	add    $0x28,%rsp  
   0x0000000000400f40 <+68>:	pop    %rbx  
   0x0000000000400f41 <+69>:	pop    %rbp  
   0x0000000000400f42 <+70>:	retq  

看到在+9处调用了一个函数`read_six_numbers`,可以猜到这次是要输入6个数字。然后+14起的三行比较rsp的值是否与1相等，若不等则调用`explode_bomb`——显然就是爆炸了；相等则跳转到+52处。**由此可知第一个数应该是1**。先不管函数的具体内容，然后可以在纸上画一下程序的流程图，可以发现接下来是一个循环，循环终止的条件是rbx和rbp的值相等。rbx由rsp+4开始，到rbp(即rsp+24)结束，每一次循环rbx地址都会+4，这样是就循环5次，刚好判断接下来的5个数。细看循环内容，是把rbx-4的值赋予eax，然后乘2，再与rbx的值比较是否相等。**也就是说每一个数都要是上一个数的两倍！** 答案也就出来了：1 2 4 8 16 32，第二个炸弹拆除。  

细究一下，可以看看函数`read_six_numbers`的内容如下：
>(gdb) disas read_six_numbers  
Dump of assembler code for function read_six_numbers:  
   0x000000000040145c <+0>:	sub    $0x18,%rsp  
   0x0000000000401460 <+4>:	mov    %rsi,%rdx  
   0x0000000000401463 <+7>:	lea    0x4(%rsi),%rcx  
   0x0000000000401467 <+11>:	lea    0x14(%rsi),%rax  
   0x000000000040146b <+15>:	mov    %rax,0x8(%rsp)  
   0x0000000000401470 <+20>:	lea    0x10(%rsi),%rax  
   0x0000000000401474 <+24>:	mov    %rax,(%rsp)  
   0x0000000000401478 <+28>:	lea    0xc(%rsi),%r9  
   0x000000000040147c <+32>:	lea    0x8(%rsi),%r8  
   0x0000000000401480 <+36>:	mov    $0x4025c3,%esi  
   0x0000000000401485 <+41>:	mov    $0x0,%eax  
   0x000000000040148a <+46>:	callq  0x400bf0 <__isoc99_sscanf@plt>  
   0x000000000040148f <+51>:	cmp    $0x5,%eax  
   0x0000000000401492 <+54>:	jg     0x401499 <read_six_numbers+61>  
   0x0000000000401494 <+56>:	callq  0x40143a <explode_bomb>  
   0x0000000000401499 <+61>:	add    $0x18,%rsp  
   0x000000000040149d <+65>:	retq   

开头的mov和lea都是在为将要输入的参数分配空间，会发现这里也是每一个数相隔4个字节（rsi,rsi+4,...）。在+46处，调用了一个scanf，同时前面又出现了一个传到esi中的立即数参数，看下它的内容：
>(gdb) x/s 0x4025c3  
0x4025c3:	"%d %d %d %d %d %d"

没错，就是输入了6个整数。也验证了每个数地址都是相隔4个字节，int型是32位。
## phase_3
老样子，先看phase_3的内容：
>(gdb) disas phase_3  
Dump of assembler code for function phase_3:  
   0x0000000000400f43 <+0>:	sub    $0x18,%rsp  
   0x0000000000400f47 <+4>:	lea    0xc(%rsp),%rcx  
   0x0000000000400f4c <+9>:	lea    0x8(%rsp),%rdx  
   0x0000000000400f51 <+14>:	mov    $0x4025cf,%esi  
   0x0000000000400f56 <+19>:	mov    $0x0,%eax  
   0x0000000000400f5b <+24>:	callq  0x400bf0 <__isoc99_sscanf@plt>  
   0x0000000000400f60 <+29>:	cmp    $0x1,%eax  
   0x0000000000400f63 <+32>:	jg     0x400f6a <phase_3+39>  
   0x0000000000400f65 <+34>:	callq  0x40143a <explode_bomb>  
   0x0000000000400f6a <+39>:	cmpl   $0x7,0x8(%rsp)  
   0x0000000000400f6f <+44>:	ja     0x400fad <phase_3+106>  
   0x0000000000400f71 <+46>:	mov    0x8(%rsp),%eax  
   0x0000000000400f75 <+50>:	jmpq   *0x402470(,%rax,8)  
   0x0000000000400f7c <+57>:	mov    $0xcf,%eax  
   0x0000000000400f81 <+62>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400f83 <+64>:	mov    $0x2c3,%eax  
   0x0000000000400f88 <+69>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400f8a <+71>:	mov    $0x100,%eax  
   0x0000000000400f8f <+76>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400f91 <+78>:	mov    $0x185,%eax  
   0x0000000000400f96 <+83>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400f98 <+85>:	mov    $0xce,%eax  
   0x0000000000400f9d <+90>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400f9f <+92>:	mov    $0x2aa,%eax  
   0x0000000000400fa4 <+97>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400fa6 <+99>:	mov    $0x147,%eax  
   0x0000000000400fab <+104>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400fad <+106>:	callq  0x40143a <explode_bomb>  
   0x0000000000400fb2 <+111>:	mov    $0x0,%eax  
   0x0000000000400fb7 <+116>:	jmp    0x400fbe <phase_3+123>  
   0x0000000000400fb9 <+118>:	mov    $0x137,%eax  
   0x0000000000400fbe <+123>:	cmp    0xc(%rsp),%eax  
   0x0000000000400fc2 <+127>:	je     0x400fc9 <phase_3+134>  
   0x0000000000400fc4 <+129>:	callq  0x40143a <explode_bomb>  
   0x0000000000400fc9 <+134>:	add    $0x18,%rsp  
   0x0000000000400fcd <+138>:	retq   

一眼看到熟悉的scanf，和上题类似，先看看它的参数是什么：
>(gdb) x/s 0x4025cf  
0x4025cf:	"%d %d"

看来这次是输入了两个整数。sscanf返回后先是判断了eax是否大于1，这里实际是返回了输入的参数个数，输入两个数即返回2。然后判断了rsp+8地址的值是否小于等于7，然后将rsp+8赋值给eax，并跳转到`rax*8+0x402470`的**内容**对应的地址。  
这里我有两个疑问：一是rsp+8是什么内容？二是eax是rax的低32位，rax的高位都是0吗？理解深入的同学可能可以直接判断吧。我这里是通过`break`设置断点，再`run`运行，再`nexti`单步调试的方式，到相关地址后使用`print /d ($rsp+8)`发现rsp+8即你输入的第一个参数。同样也可以`print /d (int)$rax`打印rax的值。  
回到前面继续，**假如我们输入的第一个参数为2**，则rax*8+0x402470=0x402480。然后`print /x *0x402480`查看该地址的值为：
>(gdb) print /x *0x402480  
$1 = 0x400f83

去phase_3的代码中找到0x400f83地址对应的代码为：
>0x0000000000400f83 <+64>:	mov    $0x2c3,%eax  

然后会跳转到+123处与rsp+12的内容(也就是第二个参数)比较是否相等。**所以这个0x2c3也就是十进制的707，就是我们的第二个参数**。汇编代码中可以看出，本题的答案是不唯一的，只要满足第一个参数小于等于7（还要大于等于0，小于0的数测试发现没有对应项）然后类似的找到对应的第二个参数即可。
## phase_4
话不多说：
>Dump of assembler code for function phase_4:  
   0x000000000040100c <+0>:	sub    $0x18,%rsp  
   0x0000000000401010 <+4>:	lea    0xc(%rsp),%rcx  
   0x0000000000401015 <+9>:	lea    0x8(%rsp),%rdx  
   0x000000000040101a <+14>:	mov    $0x4025cf,%esi  
   0x000000000040101f <+19>:	mov    $0x0,%eax  
   0x0000000000401024 <+24>:	callq  0x400bf0 <__isoc99_sscanf@plt>  
   0x0000000000401029 <+29>:	cmp    $0x2,%eax  
   0x000000000040102c <+32>:	jne    0x401035 <phase_4+41>  
   0x000000000040102e <+34>:	cmpl   $0xe,0x8(%rsp)  
   0x0000000000401033 <+39>:	jbe    0x40103a <phase_4+46>  
   0x0000000000401035 <+41>:	callq  0x40143a <explode_bomb>  
   0x000000000040103a <+46>:	mov    $0xe,%edx  
   0x000000000040103f <+51>:	mov    $0x0,%esi  
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi  
   0x0000000000401048 <+60>:	callq  0x400fce <func4>  
   0x000000000040104d <+65>:	test   %eax,%eax  
   0x000000000040104f <+67>:	jne    0x401058 <phase_4+76>  
   0x0000000000401051 <+69>:	cmpl   $0x0,0xc(%rsp)  
   0x0000000000401056 <+74>:	je     0x40105d <phase_4+81>  
   0x0000000000401058 <+76>:	callq  0x40143a <explode_bomb>  
   0x000000000040105d <+81>:	add    $0x18,%rsp  
   0x0000000000401061 <+85>:	retq   


与上题一样，此处还是调用了sscanf输入两个整数。然后rsp+8也就是第一个参数值需要小于等于14(0xe)。然后调用了func4，来看看func4的内容：
>(gdb) disas func4
Dump of assembler code for function func4:  
   0x0000000000400fce <+0>:	sub    $0x8,%rsp  
   0x0000000000400fd2 <+4>:	mov    %edx,%eax  
   0x0000000000400fd4 <+6>:	sub    %esi,%eax  
   0x0000000000400fd6 <+8>:	mov    %eax,%ecx  
   0x0000000000400fd8 <+10>:	shr    $0x1f,%ecx  
   0x0000000000400fdb <+13>:	add    %ecx,%eax  
   0x0000000000400fdd <+15>:	sar    %eax  
   0x0000000000400fdf <+17>:	lea    (%rax,%rsi,1),%ecx  
   0x0000000000400fe2 <+20>:	cmp    %edi,%ecx  
   0x0000000000400fe4 <+22>:	jle    0x400ff2 <func4+36>  
   0x0000000000400fe6 <+24>:	lea    -0x1(%rcx),%edx  
   0x0000000000400fe9 <+27>:	callq  0x400fce <func4>  
   0x0000000000400fee <+32>:	add    %eax,%eax  
   0x0000000000400ff0 <+34>:	jmp    0x401007 <func4+57>  
   0x0000000000400ff2 <+36>:	mov    $0x0,%eax  
   0x0000000000400ff7 <+41>:	cmp    %edi,%ecx  
   0x0000000000400ff9 <+43>:	jge    0x401007 <func4+57>  
   0x0000000000400ffb <+45>:	lea    0x1(%rcx),%esi  
   0x0000000000400ffe <+48>:	callq  0x400fce <func4>  
   0x0000000000401003 <+53>:	lea    0x1(%rax,%rax,1),%eax  
   0x0000000000401007 <+57>:	add    $0x8,%rsp  
   0x000000000040100b <+61>:	retq  

在纸上写写计算过程，发现到+22处，ecx的值为7，edi为输入的第一个参数，此时需要参数**大于等于7**条件成立。先假设条件成立，则跳到+36处，这里把eax置0，然后edi和ecx又比了一次，参数**小于等于7**就能跳到最后。先忽略其他内容，**那么就可推断出第一个参数为7是可以成立的**。回到phase_4主函数，+69处rsp+12（也就是第二个参数）与0比较是否相等，所以**第二个参数肯定是0**。这样第四个炸弹也拆掉了。  
回到func4，看看其他的情况,若第一个参数小于7，则会进入一个递归过程。可以尝试写一下C代码，不过还没有太搞明白什么数是符合条件的……暂时先跳过。

## phase_5
>Dump of assembler code for function phase_5:  
   0x0000000000401062 <+0>:	push   %rbx  
   0x0000000000401063 <+1>:	sub    $0x20,%rsp  
   0x0000000000401067 <+5>:	mov    %rdi,%rbx  
   0x000000000040106a <+8>:	mov    %fs:0x28,%rax  
   0x0000000000401073 <+17>:	mov    %rax,0x18(%rsp)  
   0x0000000000401078 <+22>:	xor    %eax,%eax  
   0x000000000040107a <+24>:	callq  0x40131b <string_length>  
   0x000000000040107f <+29>:	cmp    $0x6,%eax  
   0x0000000000401082 <+32>:	je     0x4010d2 <phase_5+112>  
   0x0000000000401084 <+34>:	callq  0x40143a <explode_bomb>  
   0x0000000000401089 <+39>:	jmp    0x4010d2 <phase_5+112>  
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx  
   0x000000000040108f <+45>:	mov    %cl,(%rsp)  
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx  
   0x0000000000401096 <+52>:	and    $0xf,%edx  
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx  
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1)  
   0x00000000004010a4 <+66>:	add    $0x1,%rax  
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax  
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>  
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp)  
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi  
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi  
   0x00000000004010bd <+91>:	callq  0x401338 <strings_not_equal>  
   0x00000000004010c2 <+96>:	test   %eax,%eax  
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>  
   0x00000000004010c6 <+100>:	callq  0x40143a <explode_bomb>  
   0x00000000004010cb <+105>:	nopl   0x0(%rax,%rax,1)  
   0x00000000004010d0 <+110>:	jmp    0x4010d9 <phase_5+119>  
   0x00000000004010d2 <+112>:	mov    $0x0,%eax  
   0x00000000004010d7 <+117>:	jmp    0x40108b <phase_5+41>  
   0x00000000004010d9 <+119>:	mov    0x18(%rsp),%rax  
   0x00000000004010de <+124>:	xor    %fs:0x28,%rax  
   0x00000000004010e7 <+133>:	je     0x4010ee <phase_5+140>  
   0x00000000004010e9 <+135>:	callq  0x400b30 <__stack_chk_fail\@plt>  
   0x00000000004010ee <+140>:	add    $0x20,%rsp  
   0x00000000004010f2 <+144>:	pop    %rbx  
   0x00000000004010f3 <+145>:	retq   

一上来发现调用了函数string_length，判断输入字符串长度应该为6。然后发现从+41开始是一个循环，每次rax会+1，rbx就是输入字符串的起始地址（+5处由rdi传入），于是rbx+rax就是在遍历每个字符。把每个字符传递给rcx再到rdx，然后与0xf，就是取了低4位。再把这4位数+上0x4024b0地址。然后把新的dx放到rsp+16起始的一片地址(每次+rax，即到下一个位置)中。当rax=6时结束循环。然后调用了strings_not_equal比较字符串，这个函数是比较si和di的内容（disas查看，前面也有用过）。+81处为si赋值了一个立即数，我们可以查看`x/s 0x40245e`：
>(gdb) x/s 0x40245e  
0x40245e:	"flyers"

而di是rsp+16，也就是前面循环中操作的地址。由此可以推断这个程序**是将输入的字符串进行一定的处理后将得到flyers**。如何处理**关键在于+55处的0x4024b0地址内容**，我们同样可以查看`x/s 0x40245e`：
>(gdb) x/s 0x4024b0  
0x4024b0 <array.3449>:	"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"

所以**输入的字符串每个字符的低四位，就是答案在这个字符串中的所在位置**，flyers几个字母分别在第9 15 14 5 6 7位上，也就是0x9 0xf 0xe 0x5 0x6 0x7,我们任意输入低四位是这几个数的字符即可。我这里输入的是ionefg，即0x69 0x6f 0x6e 0x65 0x66 0x67,输入高4位是其他数的字符也是可以的，如Y_^UVW（高四位是5），对照ascii码表输入就好。

## phase_6
第六题好长啊！而且条件跳转非常的多！所以我打算分块来看，先看第一部分：
>(gdb) disas phase_6  
Dump of assembler code for function phase_6:  
   0x00000000004010f4 <+0>:	push   %r14
   0x00000000004010f6 <+2>:	push   %r13  
   0x00000000004010f8 <+4>:	push   %r12  
   0x00000000004010fa <+6>:	push   %rbp  
   0x00000000004010fb <+7>:	push   %rbx  
   0x00000000004010fc <+8>:	sub    $0x50,%rsp  
   0x0000000000401100 <+12>:	mov    %rsp,%r13  
   0x0000000000401103 <+15>:	mov    %rsp,%rsi  
   0x0000000000401106 <+18>:	callq  0x40145c <read_six_numbers>  
   0x000000000040110b <+23>:	mov    %rsp,%r14  
   0x000000000040110e <+26>:	mov    $0x0,%r12d  
   0x0000000000401114 <+32>:	mov    %r13,%rbp  
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax  
   0x000000000040111b <+39>:	sub    $0x1,%eax  
   0x000000000040111e <+42>:	cmp    $0x5,%eax  
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>  
   0x0000000000401123 <+47>:	callq  0x40143a <explode_bomb>  
   0x0000000000401128 <+52>:	add    $0x1,%r12d  
   0x000000000040112c <+56>:	cmp    $0x6,%r12d  
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>  
   0x0000000000401132 <+62>:	mov    %r12d,%ebx  
   0x0000000000401135 <+65>:	movslq %ebx,%rax  
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax  
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)  
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>  
   0x0000000000401140 <+76>:	callq  0x40143a <explode_bomb>  
   0x0000000000401145 <+81>:	add    $0x1,%ebx  
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx  
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>  
   0x000000000040114d <+89>:	add    $0x4,%r13  
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32>  
*省略……*  

可以看到一开始是读取了6个数字。然后+32到+93处是一个两层嵌套的循环，这里经我断点测试，r13即指向输入的数(因为前面rsp给r13传递的是地址还是值我一直搞不清楚……)，外层的循环是遍历6个数，内层的循环是把当前数与后面的几个数进行比较。**达到的效果就是判断6个数互不相等**，否则bomb。循环中还有一个条件是输入的数减1小于等于5，即**输入的数小于等于6**。  
>*续上一部分*  
   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi  
   0x0000000000401158 <+100>:	mov    %r14,%rax  
   0x000000000040115b <+103>:	mov    $0x7,%ecx  
   0x0000000000401160 <+108>:	mov    %ecx,%edx  
   0x0000000000401162 <+110>:	sub    (%rax),%edx  
   0x0000000000401164 <+112>:	mov    %edx,(%rax)  
   0x0000000000401166 <+114>:	add    $0x4,%rax  
   0x000000000040116a <+118>:	cmp    %rsi,%rax  
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>  

然后+108至+118处又是一个循环，这里的r14还是指向输入6个数的第一个。循环退出的条件是要与rsi相等，rsi由+95处被赋值为rsp+24，也就是这6个数结束的地址。所以这个**循环是遍历6个数，并用7减每个数，即rax=7-rax**。  
>*续上一部分*  
   0x000000000040116f <+123>:	mov    $0x0,%esi  
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163>  
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx  
   0x000000000040117a <+134>:	add    $0x1,%eax  
   0x000000000040117d <+137>:	cmp    %ecx,%eax  
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>  
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>  
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx  
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2)  
   0x000000000040118d <+153>:	add    $0x4,%rsi  
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi  
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>  
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx  
   0x000000000040119a <+166>:	cmp    $0x1,%ecx  
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143>  
   0x000000000040119f <+171>:	mov    $0x1,%eax  
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx  
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>  

接下来一块内容显得有点混乱，从+128跳转到+163，又从+166跳到+143，或者从+141跳到+148，然后又可能从+157跳回+163……其实还是循环，只是有条件分叉，总之需要耐心。从+163开始，第一次rsi为0，这里ecx也就等于输入的第一个数，然后**判断该数是否小于等于1**。  
接着程序在这里分叉了，先假设小于等于1的情况：跳转到+143，这里有个立即数0x6032d0,还不清楚是什么。然后+148把rax放到了rsp+32开头的一片空间中（间隔为8）。然后rsi+=4，并判断是否等于24，可见这里又是遍历6个数了。回到+163，开始判断第二个数是否小于等于1。再看大于1的情况：eax从1开始，每次自加1，直到与该数(ecx)相等。每次rdx要向后移动8个字节。然后到+148处，分支又合并了。  
**若数大于1，rdx则每次+8；若数小于等于1，rdx=0x6032d0**然后放到rsp+32开始的一片空间中。小于等于1的数得到的指针指向同一个地址0x6032d0。这一段实在没能理解，看了别人的解答后，这实际上是一个**链表**。我们用`x/g`命令查看某地址开始的8个字节：
>(gdb) x/12xg 0x6032d0  
0x6032d0 <node1>:	0x000000010000014c	0x00000000006032e0  
0x6032e0 <node2>:	0x00000002000000a8	0x00000000006032f0  
0x6032f0 <node3>:	0x000000030000039c	0x0000000000603300  
0x603300 <node4>:	0x00000004000002b3	0x0000000000603310  
0x603310 <node5>:	0x00000005000001dd	0x0000000000603320  
0x603320 <node6>:	0x00000006000001bb	0x0000000000000000  

我们看右边那一列即下一个结点的地址，即指向下一个结点的指针，说明这确实是一个链表。前8个字节则是数据。**有个可能比较难理解（比较绕）的地方在于为什么rdx每次是+8，因为node首地址+8的“值”即下个结点的首地址，因此上面大于1的数N其实对应的就是nodeN**。到底是一个地址还是地址中的内容（地址的内容可能还是地址）总是很容易搞糊涂。

>*续上一部分*   
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx  
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax  
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi  
   0x00000000004011ba <+198>:	mov    %rbx,%rcx  
   0x00000000004011bd <+201>:	mov    (%rax),%rdx  
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)  
   0x00000000004011c4 <+208>:	add    $0x8,%rax  
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax  
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>  
   0x00000000004011cd <+217>:	mov    %rdx,%rcx  
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>  
    
这一段的开头将rbx=rsp+32，rax=rsp+40,rsi=rsp+80，rsp+32即上一部分操作的那片空间的起始地址，rsp+80即结束地址（见+148处，rsp+2*24+32）。**rax代表的是第一个（rps+32）结点的指针部分**这里+201到+220又是一个循环，循环遍历rsp+32开始的6个结点。这里要注意取的是rax的值，而不是寻址，也就是**将第一个(rsp+32)结点的指针指向第二个(rsp+40)结点**。以此类推，调整链表的指针，使得在rsp+32这片空间上的各个结点是前后相连的。
>*续上一部分*  
   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)  
   0x00000000004011da <+230>:	mov    $0x5,%ebp  
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax  
   0x00000000004011e3 <+239>:	mov    (%rax),%eax  
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)  
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>  
   0x00000000004011e9 <+245>:	callq  0x40143a <explode_bomb>  
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx  
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp  
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>  
   0x00000000004011f7 <+259>:	add    $0x50,%rsp  
   0x00000000004011fb <+263>:	pop    %rbx  
   0x00000000004011fc <+264>:	pop    %rbp  
   0x00000000004011fd <+265>:	pop    %r12  
   0x00000000004011ff <+267>:	pop    %r13  
   0x0000000000401201 <+269>:	pop    %r14  
   0x0000000000401203 <+271>:	retq  

这一段还是有循环，ebp要从5自减1到0。rbx仍是指向rsp+32，这里要求**前一个结点的数要大于等于后一个结点的数**，否则bomb。要注意+239处**只取了低32位**，我们只关注结点数据中的低位即可。

这样分段就分析完了，我们还要串起来。看加粗部分的主要结论。根据最后一个结论，可以反推出最后的链表状态为：**node3>node4>node5>node6>node1>node2** (注意这里的序号指链表初始状态的顺序，即前面从0x6032d0开始的顺序，而不是从rsp+32开始的顺序)。根据前面的结论，这里序号就是要求的数。再往前每个数要被7减过，反推得**4 3 2 1 6 5**!!!结束！！！！